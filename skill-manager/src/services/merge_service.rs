//! Skill merging service implementation

use std::sync::Arc;

use async_trait::async_trait;
use chrono::Utc;

use crate::domain::{DomainEvent, EventBus, Skill, SkillScope};
use crate::utils::error::Result;

use super::traits::{MergeService as MergeServiceTrait, OutputStorage, SkillRepository, SkillStorage};

/// Implementation of the merge service
pub struct MergeServiceImpl<R, S, O>
where
    R: SkillRepository,
    S: SkillStorage,
    O: OutputStorage,
{
    repository: Arc<R>,
    storage: Arc<S>,
    output: Arc<O>,
    event_bus: Arc<std::sync::RwLock<EventBus>>,
}

impl<R, S, O> MergeServiceImpl<R, S, O>
where
    R: SkillRepository,
    S: SkillStorage,
    O: OutputStorage,
{
    /// Create a new merge service
    pub fn new(
        repository: Arc<R>,
        storage: Arc<S>,
        output: Arc<O>,
        event_bus: Arc<std::sync::RwLock<EventBus>>,
    ) -> Self {
        Self {
            repository,
            storage,
            output,
            event_bus,
        }
    }

    /// Publish an event
    fn publish_event(&self, event: DomainEvent) {
        if let Ok(bus) = self.event_bus.read() {
            bus.publish(&event);
        }
    }
}

#[async_trait]
impl<R, S, O> MergeServiceTrait for MergeServiceImpl<R, S, O>
where
    R: SkillRepository + 'static,
    S: SkillStorage + 'static,
    O: OutputStorage + 'static,
{
    async fn merge(&self, scope: &SkillScope) -> Result<String> {
        // Get enabled skills for this scope
        let mut skills = self.repository.list_enabled().await?;

        // Filter by scope (include global skills and matching project skills)
        skills.retain(|s| {
            s.scope == SkillScope::Global || &s.scope == scope
        });

        // Sort by priority (descending - higher priority first)
        skills.sort_by(|a, b| b.priority.cmp(&a.priority));

        // Load content for each skill
        let mut skill_contents: Vec<(Skill, String)> = Vec::new();
        for skill in skills {
            if let Ok(content) = self.storage.read(skill.id).await {
                skill_contents.push((skill, content));
            }
        }

        // Merge the content
        let merged = merge_skill_contents(&skill_contents);

        // Write output
        self.output.write_claude_md(scope, &merged).await?;

        // Publish event
        self.publish_event(DomainEvent::SkillsMerged {
            skill_count: skill_contents.len(),
            output_path: self.output.get_claude_md_path(scope).display().to_string(),
            timestamp: Utc::now(),
        });

        Ok(merged)
    }

    async fn rebuild_all(&self) -> Result<()> {
        // Get all unique scopes
        let skills = self.repository.list().await?;
        let mut scopes: Vec<SkillScope> = vec![SkillScope::Global];

        for skill in &skills {
            if !scopes.contains(&skill.scope) {
                scopes.push(skill.scope.clone());
            }
        }

        // Rebuild each scope
        for scope in scopes {
            self.merge(&scope).await?;
        }

        Ok(())
    }
}

/// Merge multiple skill contents into a single CLAUDE.md
pub fn merge_skill_contents(skills: &[(Skill, String)]) -> String {
    let mut output = String::new();

    // Add header
    output.push_str("<!-- Generated by Claude Skill Manager -->\n");
    output.push_str("<!-- Do not edit directly - changes will be overwritten -->\n");
    output.push_str(&format!("<!-- Generated at: {} -->\n", Utc::now().format("%Y-%m-%d %H:%M:%S UTC")));
    output.push_str("\n");

    if skills.is_empty() {
        output.push_str("# Claude Instructions\n\n");
        output.push_str("No skills are currently enabled.\n");
        return output;
    }

    // Parse and merge sections
    let mut sections: Vec<MergedSection> = Vec::new();

    for (skill, content) in skills {
        let parsed = parse_content(content);

        for section in parsed {
            // Check if we already have this section
            if let Some(existing) = sections.iter_mut().find(|s| s.heading == section.heading) {
                // Merge content
                existing.content.push_str("\n\n");
                existing.content.push_str(&format!("<!-- From: {} -->\n", skill.name));
                existing.content.push_str(&section.content);
                existing.sources.push(skill.name.clone());
            } else {
                // New section
                sections.push(MergedSection {
                    heading: section.heading,
                    content: format!("<!-- From: {} -->\n{}", skill.name, section.content),
                    sources: vec![skill.name.clone()],
                });
            }
        }
    }

    // Build output
    for section in sections {
        if !section.heading.is_empty() {
            output.push_str(&section.heading);
            output.push_str("\n\n");
        }
        output.push_str(&section.content);
        output.push_str("\n\n");
    }

    output.trim_end().to_string()
}

/// A parsed section from skill content
#[derive(Debug)]
struct ParsedSection {
    heading: String,
    content: String,
}

/// A merged section with content from multiple skills
#[derive(Debug)]
struct MergedSection {
    heading: String,
    content: String,
    sources: Vec<String>,
}

/// Parse content into sections
fn parse_content(content: &str) -> Vec<ParsedSection> {
    let mut sections = Vec::new();
    let mut current_heading = String::new();
    let mut current_content = String::new();

    for line in content.lines() {
        // Check for markdown headings
        if line.starts_with('#') {
            // Save previous section if it has content
            if !current_content.trim().is_empty() || !current_heading.is_empty() {
                sections.push(ParsedSection {
                    heading: current_heading.clone(),
                    content: current_content.trim().to_string(),
                });
            }
            current_heading = line.to_string();
            current_content = String::new();
        } else {
            current_content.push_str(line);
            current_content.push('\n');
        }
    }

    // Don't forget the last section
    if !current_content.trim().is_empty() || !current_heading.is_empty() {
        sections.push(ParsedSection {
            heading: current_heading,
            content: current_content.trim().to_string(),
        });
    }

    sections
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::SkillSource;

    fn make_skill(name: &str, priority: i32) -> Skill {
        let mut skill = Skill::new(name, SkillSource::Inline, SkillScope::Global);
        skill.priority = priority;
        skill
    }

    #[test]
    fn test_merge_empty() {
        let result = merge_skill_contents(&[]);
        assert!(result.contains("No skills are currently enabled"));
    }

    #[test]
    fn test_merge_single_skill() {
        let skill = make_skill("test", 50);
        let content = "# Test\n\nSome content here.";

        let result = merge_skill_contents(&[(skill, content.to_string())]);

        assert!(result.contains("# Test"));
        assert!(result.contains("Some content here"));
        assert!(result.contains("From: test"));
    }

    #[test]
    fn test_merge_preserves_priority_order() {
        let skill_high = make_skill("high", 100);
        let skill_low = make_skill("low", 10);

        // Note: skills should already be sorted by priority before calling merge
        let skills = vec![
            (skill_high, "# High Priority\n\nHigh content.".to_string()),
            (skill_low, "# Low Priority\n\nLow content.".to_string()),
        ];

        let result = merge_skill_contents(&skills);

        // High priority content should appear before low
        let high_pos = result.find("High content").unwrap();
        let low_pos = result.find("Low content").unwrap();
        assert!(high_pos < low_pos);
    }

    #[test]
    fn test_merge_combines_same_sections() {
        let skill_a = make_skill("skill-a", 100);
        let skill_b = make_skill("skill-b", 50);

        let skills = vec![
            (skill_a, "# Code Style\n\nUse tabs.".to_string()),
            (skill_b, "# Code Style\n\nBe consistent.".to_string()),
        ];

        let result = merge_skill_contents(&skills);

        // Should only have one "# Code Style" heading
        let heading_count = result.matches("# Code Style").count();
        assert_eq!(heading_count, 1);

        // But both contents should be present
        assert!(result.contains("Use tabs"));
        assert!(result.contains("Be consistent"));
    }

    #[test]
    fn test_parse_content_basic() {
        let content = "# Heading 1\n\nContent 1\n\n# Heading 2\n\nContent 2";
        let sections = parse_content(content);

        assert_eq!(sections.len(), 2);
        assert_eq!(sections[0].heading, "# Heading 1");
        assert_eq!(sections[0].content, "Content 1");
        assert_eq!(sections[1].heading, "# Heading 2");
        assert_eq!(sections[1].content, "Content 2");
    }

    #[test]
    fn test_parse_content_no_headings() {
        let content = "Just some content\nwith multiple lines.";
        let sections = parse_content(content);

        assert_eq!(sections.len(), 1);
        assert!(sections[0].heading.is_empty());
        assert!(sections[0].content.contains("Just some content"));
    }
}
